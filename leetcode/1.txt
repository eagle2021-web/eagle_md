class FreqStack {
public:
    int mf = 0;
    unordered_map<int, stack<int>> m;
    unordered_map<int, int > cnts;
    FreqStack() {

    }

    void push(int val) {
        cnts[val]++;
        m[cnts[val]].push(val);
        mf = max(cnts[val], mf);
    }

    int pop() {
        int pop_val = m[mf].top();
        m[mf].pop();
        if(m[mf].empty())mf--;
        cnts[pop_val]--;
        return pop_val;
    }
};
   int minOperations(string s) {
        int cnt = 0, p = 0;
        for (char &c: s) {
            int tmp = c - '0';
            if ((p ^ tmp) == 1)cnt++;
            p ^= 1;
        }
        return min(cnt, int(s.size() - cnt));
    }

    double largestSumOfAverages(vector<int> &nums, int m) {
        int n = nums.size();
        vector<vector<double>> dp(n + 1, vector<double>(m + 1, 0));
        vector<int> sums(n + 1, 0);
        for(int i = 0; i < n; i++){
            sums[i + 1] = sums[i] + nums[i];
        }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= min(i, m); j++){
                if(j == 1){
                    dp[i][j] = double (sums[i]) / i;
                    continue;
                }
                for(int k = 1; k < i ; k++){
                    double tmp = dp[k][j - 1] + double(sums[i] - sums[k]) / (i - k);
                    dp[i][j] = max(dp[i][j], tmp);
                }
            }
        }
        return dp[n][m];
    }
    map<int, int> cnts;
    map<int, vector<int>> m_list;
    int cur_max = 0;
    FreqStack() {

    }

    void push(int val) {
        cnts[val]++;
        int cnt = cnts[val];
        m_list[cnt].push_back(val);
        cur_max = max(cur_max, cnt);
    }

    int pop() {
       int ret = m_list[cur_max].back();
       m_list[cur_max].pop_back();
       if(m_list[cur_max].empty()) {
           cur_max--;
       }
        return ret;
    }
    int minOperations(string s) {
        int size = s.size();
        int p = 0, cnt = 0;
        for(char const c: s) {
            cnt += ((c - '0') ^ p) == 1 ? 0 : 1;
            p ^= 1;
        }
        return min(cnt, size - cnt);
    }
    bool check(vector<int>& nums) {
        int cur = 110;
        for(int i = 0; i < nums.size(); ){
            while(i + 1 < nums.size() && nums[i] < nums[i + 1]){
                if(nums[i] > cur){
                    return false;
                }
            }
            if(nums[i] > cur)return false;
            cur = nums[i];
            i++;
        }
        return true;
    }
    int expressiveWords(string s, vector<string>& words) {
        int n = s.size(), ans = 0;
        for(string &s2: words){
            int m = s2.size();
            int i = 0, j = 0;
            bool ok = true;
            while (i < n && j < m){
                if(s[i] != s2[j]){
                    ok = false;
                    break;
                }
                int a = i + 1, b = j + 1;
                while(a < n && s[a - 1] == s[a])a++;
                while (b < m && s2[b - 1] == s2[b])b++;
                int len1 = a - i, len2 = b - j;
                if(len1 != len2 && (len2 > len1 || len1 < 3)){
                    ok = false;
                    break;
                }
                i = a;
                j = b;
            }
            if(ok && i == n && j == m)ans++;
        }
        return ans;
    }