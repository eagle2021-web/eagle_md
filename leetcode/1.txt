class FreqStack {
public:
    int mf = 0;
    unordered_map<int, stack<int>> m;
    unordered_map<int, int > cnts;
    FreqStack() {

    }

    void push(int val) {
        cnts[val]++;
        m[cnts[val]].push(val);
        mf = max(cnts[val], mf);
    }

    int pop() {
        int pop_val = m[mf].top();
        m[mf].pop();
        if(m[mf].empty())mf--;
        cnts[pop_val]--;
        return pop_val;
    }
};
   int minOperations(string s) {
        int cnt = 0, p = 0;
        for (char &c: s) {
            int tmp = c - '0';
            if ((p ^ tmp) == 1)cnt++;
            p ^= 1;
        }
        return min(cnt, int(s.size() - cnt));
    }

    double largestSumOfAverages(vector<int> &nums, int m) {
        int n = nums.size();
        vector<vector<double>> dp(n + 1, vector<double>(m + 1, 0));
        vector<int> sums(n + 1, 0);
        for(int i = 0; i < n; i++){
            sums[i + 1] = sums[i] + nums[i];
        }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= min(i, m); j++){
                if(j == 1){
                    dp[i][j] = double (sums[i]) / i;
                    continue;
                }
                for(int k = 1; k < i ; k++){
                    double tmp = dp[k][j - 1] + double(sums[i] - sums[k]) / (i - k);
                    dp[i][j] = max(dp[i][j], tmp);
                }
            }
        }
        return dp[n][m];
    }
    bool check(vector<int> &nums) {
        int cnt = 2, n = nums.size(), min_val = 110, i = 0;
        while (cnt > 0 && i < n) {
            cnt--;
            int tmp_min = nums[i];
            while (i + 1 < n && nums[i] <= nums[i + 1]) {
                if(nums[i] > min_val)return false;
                i++;
            }
            if(nums[i] > min_val)return false;
            min_val = tmp_min;
            i++;
        }
        std::cout << i << endl;
        return i == n;
    }
        int reachableNodes(vector<vector<int>> &edges, int maxMoves, int n) {
            int max_val = INT32_MAX / 2 - 4000;
            vector<int> dist(n, max_val);
            vector<bool> vis(n, false);
            int **neis = new int * [n]{{0}};
            for(auto &v: edges){
                int l = v[0], r = v[1], val = v[2];
                neis[l][r] = val + 1;
                neis[r][l] = val + 1;
            }
            dist[0] = 0;

            for(int i = 0; i < n; i++){
                int start = -1;
                for(int j = 0;j < n; j++){
                    if(vis[j])continue;
                    if(start == -1 || dist[j] < dist[start])start = j;
                }
                vis[start] = true;
                vector<int> &nei = neis[start];
                // cout << "===" << start <<endl;
                for(int j = 0; j < n; j++){
                    dist[j] = min(dist[j], nei[j] + dist[start]);
                    // cout << "j == " << j << "dist[j] = " << dist[j] << endl;
                }
            }
            int ans = 0;
            for(auto &num: dist){
                if(num <= maxMoves)ans++;
            }
            for (int i = 0; i < dist.size(); ++i) {
                cout << dist[i] << " ";
            }
            // cout << endl;
            // cout << ans << endl;
            for(int i = 0; i < edges.size(); i++){
                auto &info = edges[i];
                int l = info[0], r = info[1], distance = info[2];
                int left = max(0,  maxMoves - dist[l]), right = max(0, maxMoves - dist[r]);
                ans += min(left + right, distance);
                // cout << min(left + right, distance) << endl;
            }
            return ans;
        }
    map<int, int> cnts;
    map<int, vector<int>> m_list;
    int cur_max = 0;
    FreqStack() {

    }

    void push(int val) {
        cnts[val]++;
        int cnt = cnts[val];
        m_list[cnt].push_back(val);
        cur_max = max(cur_max, cnt);
    }

    int pop() {
       int ret = m_list[cur_max].back();
       m_list[cur_max].pop_back();
       if(m_list[cur_max].empty()) {
           cur_max--;
       }
        return ret;
    }
    int minOperations(string s) {
        int size = s.size();
        int p = 0, cnt = 0;
        for(char const c: s) {
            cnt += ((c - '0') ^ p) == 1 ? 0 : 1;
            p ^= 1;
        }
        return min(cnt, size - cnt);
    }
    bool check(vector<int>& nums) {
        int cur = 110;
        for(int i = 0; i < nums.size(); ){
            while(i + 1 < nums.size() && nums[i] < nums[i + 1]){
                if(nums[i] > cur){
                    return false;
                }
            }
            if(nums[i] > cur)return false;
            cur = nums[i];
            i++;
        }
        return true;
    }
    int expressiveWords(string s, vector<string>& words) {
        int n = s.size(), ans = 0;
        for(string &s2: words){
            int m = s2.size();
            int i = 0, j = 0;
            bool ok = true;
            while (i < n && j < m){
                if(s[i] != s2[j]){
                    ok = false;
                    break;
                }
                int a = i + 1, b = j + 1;
                while(a < n && s[a - 1] == s[a])a++;
                while (b < m && s2[b - 1] == s2[b])b++;
                int len1 = a - i, len2 = b - j;
                if(len1 != len2 && (len2 > len1 || len1 < 3)){
                    ok = false;
                    break;
                }
                i = a;
                j = b;
            }
            if(ok && i == n && j == m)ans++;
        }
        return ans;
    }