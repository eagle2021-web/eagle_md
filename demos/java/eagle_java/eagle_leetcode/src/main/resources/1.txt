    }
    public int maxProfit(int[] prices, int fee) {
        int in = Integer.MAX_VALUE, out = 0, pass = 0;
        for(int cur: prices){
            if(cur > in){
                out += cur - in;
                in = cur;
            }else if(cur + fee < in) {
                in = cur + fee;
            }
        }
        return out;
    }

    public int maxProduct(int[] nums) {
        if(nums.length == 1)return nums[0];
        int ans = 0, neg = 0, pos = 0;
        for(int cur: nums){
            if(cur == 0){
                neg = 0;
                pos = 0;
            } else if(cur > 0) {
                neg = neg * cur;
                pos = pos > 0 ? cur * pos : cur;
                ans = Math.max(pos, ans);
            } else {
                int neg2 = neg;
                neg = pos != 0 ? pos * cur : cur;
                pos = neg2 * cur;
                ans = Math.max(ans, pos);
            }
        }
        return ans;
    }
   public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for(int i = 1; i <= n; i++){
            for(int j = 0; j < i; j++){
                String s1 = s.substring(j, i);
                if(dp[j] && set.contains(s1)){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }

    public int maxProfit(int[] prices) {
        int in = -prices[0], out = 0, wait = 0;
        for(int j = 1; j < prices.length; j++){
            int o = out, i = in, w = wait;
            wait = Math.max(wait, out);
            out = Math.max(out, in + prices[j]);
            in = Math.max(in, w - prices[j]);
        }
        return out;
    }

    public int minElements(int[] nums, int limit, int goal) {
        int sum = 0;
        for(int num: nums){
            sum += num;
        }
        long dif = 0L + goal - sum;
        int ans = (int)((Math.abs(dif) - 1L) / limit + 1);
        return ans;
    }
//        s.minElements(new int[]{1, -1, 1}, 3, -4);
//        s.maxProfit(new int[]{1,2,3,0,2});
        s.wordBreak("leetcode", new ArrayList<>(Arrays.asList("leet","code")));
    public int minMoves(int[] nums, int n) {
        // dp[m][n] 代表第m个位位置有n个连续1所需要移动的次数
        int cntOne = 0;
        for(int num: nums){
            if(num > 0)cntOne++;
        }
        int m = nums.length, ans = Integer.MAX_VALUE / 2;
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 0; i <= m; i++){
            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);
        }
        dp[0][0] = 0;
        for(int i = 1; i <= m; i++){
            int t = nums[i - 1] == 1 ? 0 : 1;
            dp[i][1] = t;
            for(int j = 2; j <= n; j++){
                dp[i][j] = dp[i - 1][j - 1] + t;
            }
            if(dp[i][n] <= ans){
                ans = dp[i][n];
            }
        }
        return ans;
    }
public String getPermutation(int n, int k) {
        int[] f = new int[n + 1];
        f[0] = 1;
        for(int i = 1; i <= n; i++){
            f[i] = f[i - 1] * i;
        }
        ArrayList<Integer> list = new ArrayList<>();
        for(int i = 0; i < n; i++){
            list.add(i + 1);
        }

        StringBuffer sb = new StringBuffer();
        for(int i = 0; i < n; i++){
            int idx = (k - 1) / f[n - 1 - i];
            sb.append(list.remove(idx));
            k -= idx * f[n - 1 - i];
        }
        return sb.toString();
    }

    public int getMaxLen(int[] nums) {
        int neg = 0, pos = 0, ans = 0;
        for(int num: nums){
            if(num == 0){
                neg = 0;
                pos = 0;
                continue;
            }else if(num > 0){
                pos++;
                neg++;
            }else{
                int p = pos;
                pos = neg + 1;
                neg = p + 1;
            }
            ans = Math.max(pos, ans);
        }
        return ans;
    }
     public int getMaxLen(int[] nums) {
            int neg = 0, pos = 0, ans = 0;
            for(int num: nums){
                if(num == 0){
                    neg = 0;
                    pos = 0;
                    continue;
                }else if(num > 0){
                    pos++;
                    neg = neg > 0 ? neg + 1: 0;
                }else{
                    int p = pos;
                    pos = neg > 0 ? neg + 1 : 0;
                    neg = p + 1;
                }
                ans = Math.max(pos, ans);
            }
            return ans;
        }

        public int maxScoreSightseeingPair(int[] values) {

        }

       public int maxCoins(int[] nums) {
           int n = nums.length;
           int[] arr = new int[n + 2];
           System.arraycopy(nums, 0, arr, 1, n);
           arr[0] = arr[n + 1] = 1;
           int[][] dp = new int[n + 2][n + 2];
           for(int i = n - 1; i >= 0; i--){
               for(int j = i + 2; j <= n+1; j++){
                   for(int k = i + 1; k < j; k++){
                       dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]);
                   }
               }
           }
           return dp[0][n + 1];
       }
public List<String> wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        int[] prev = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                String s1 = s.substring(j - 1, i);
                if (wordDict.contains(s1)) {
                    dp[i] |= dp[j - 1];
                    if (dp[j - 1]) {
                        prev[i] |= 1 << (j - 1);
                    }
                }

            }
        }

        ArrayList<String> list = new ArrayList<>();
        dfs(prev, 0, s.toCharArray(), n, list);
        return list;
    }

    String assemble(int mask, char[] s) {
        StringBuffer sb = new StringBuffer();
        int cur_idx = 0;
        mask &= ~1;
        while (true){
            int low_bit = mask & -mask;
            mask ^= low_bit;
            int end_idx = Integer.numberOfTrailingZeros(low_bit);
            for(int i = cur_idx; i < end_idx; i++){
                sb.append(s[i]);
            }
            cur_idx = end_idx;
            if(cur_idx == s.length)break;
            sb.append(" ");
        }

        return sb.toString();
    }

    void dfs(int[] prev, int mask, char[] s, int i, List<String> list) {
        if (i == 0) {
            list.add(assemble(mask | (1 << s.length), s));
            return;
        }
        int candidates = prev[i];
        while (candidates != 0) {
            String tmp = Integer.toBinaryString(candidates);
            int low_bit = candidates & -candidates;
            int idx = Integer.numberOfTrailingZeros(low_bit);
            mask ^= 1 << (idx);
            dfs(prev, mask, s, idx, list);
            mask ^= 1 << (idx);
            candidates ^= low_bit;
        }
    }

   int n = 0;
    int max = 0;
    int len = 0;
    Set<String> set = new HashSet<>();
    public List<String> removeInvalidParentheses(String s) {
        int n = s.length(), l = 0, r = 0;
        char[] cs = s.toCharArray();

        for (int i = 0; i < n; i++) {
            char c = cs[i];
            if(c == '('){
                l++;
            }else if(c == ')'){
                if(l > 0){
                    l--;
                    max++;
                }else {
                    r++;
                }
            }
        }
        len = n - l - r;
        dfs(cs, 0, 0, 0, "");
        ArrayList<String> list = new ArrayList<>(set);
        return list;
    }
    void dfs(char[] cs, int idx, int l, int r, String cur){
        if(l == max && r == max && cur.length() == len){
            set.add(cur);
            return;
        }

        if(idx >= cs.length)return;
        char c = cs[idx];
        if(c == '('){
            if(l < max){
                dfs(cs, idx + 1, l + 1, r, cur + c);
            }
            dfs(cs, idx + 1, l, r, cur);
        }else if(c == ')'){
            if(r < max && l > r){
                dfs(cs, idx + 1, l, r + 1, cur + c);
            }
            dfs(cs, idx + 1, l, r, cur);
        }else {
            dfs(cs, idx + 1, l, r, cur + c);
        }
    }
    public static void main(String[] args) {
        Solution s = new Solution();
        int a = s.minDistance("intention", "execution");
        System.out.println(a);
    }

    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        int[][] dp = new int[m + 10][n + 10];
        for(int i = 0; i <= m; i++){
            for(int j = 0; j <= n; j++){
                if(i == 0){
                    dp[i][j] = j;
                    continue;
                }
                if(j == 0){
                    dp[i][j] = i;
                    continue;
                }
                char c1 = word1.charAt(i - 1), c2 = word2.charAt(j - 1);
                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                if(c1 == c2){
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
    public List<String> fullJustify(String[] words, int maxWidth) {
        int l = 0, r = 0, n = words.length();
        new ArrayList
        while(r < n){
            int cur_len = 0;
            while (r < n && cur_len + r - l <= maxWidth) {
                cur_len += s
                r++;
            }
            StringBuffer sb = new StringBuffer();
            if(r == n){
                while (l < r){
                    sb.append(words[l++]);
                    if(l !=r)sb.append(' ');
                }
                while(sb.length() < maxWidth)sb.append(" ");

            }

        }

    }
    public List<String> fullJustify(String[] words, int maxWidth) {
 //        ArrayList<String> tmp = new ArrayList<>();
 //        for (String word : words) {
 //            if(word.length() <= maxWidth)tmp.add(word);
 //        }
 //        words = tmp.toArray(new String[]{});
         int l = 0, r = 0, n = words.length;
         ArrayList<String> list = new ArrayList<String>();
         while (r < n) {
             l = r;
             int cur_len = 0;
             while (r < n && cur_len + words[r].length() + r - l <= maxWidth) {
                 cur_len += words[r].length();
                 r++;
             }
             StringBuffer sb = new StringBuffer();
             if (r == n) {
                 while (l < r) {
                     sb.append(words[l++]);
                     if (l != r) sb.append(' ');
                 }
                 while (sb.length() < maxWidth) sb.append(" ");
                 list.add(sb.toString());
                 break;
             }
             if(r - l == 1){
                 sb.append(words[l]);
                 supplementSpaces(sb, maxWidth);
                 list.add(sb.toString());
                 continue;
             }
             int dif = maxWidth - cur_len;
             int each = dif / (r - l - 1), m = dif % (r - l - 1);
             while (l < r) {
                 sb.append(words[l]);
                 if (l != r - 1) {
                     appendSpace(sb, each + (m > 0 ? 1 : 0));
                     m--;
                 }
                 l++;
             }
             System.out.println(sb.length());
             list.add(sb.toString());
         }
         return list;
     }

 public static void main(String[] args) {
        Solution s = new Solution();
        s.beautySum("aabcb");
    }
    public int beautySum(String s) {
        char[] cs = s.toCharArray();
        int n = s.length(), ans = 0;
        for(int i = 0; i < n; i++){
            int max = 1, min = 1;
            int[] freq = new int[26];
            int[] ff = new int[n +1];
            int ch = cs[i] - 'a';
            freq[ch]++;
            ff[1] = 1;
            for(int j = i; j < n; j++){
                ch = cs[j] - 'a';
                ff[freq[ch]]--;
                freq[ch]++;
                ff[freq[ch]]++;
                if(ff[min] == 0)min++;
                if(freq[ch] == 1)min = 1;
                max = Math.max(max, freq[ch]);
                ans += max - min;
            }
        }
        return ans;
    }
    public int[][] generateMatrix(int n) {

        int l = 0, r = n - 1, t = 0, b = n - 1;
        int[][] arr = new int[n][n];
        int c = 1;
        while (l <= r || t <= b){
            for(int i = l; i <= r; i++)arr[t][i] = c++;
            t++;
            for(int i = t; i <= b; i++)arr[i][r] = c++;
            r--;
            for(int i = r; i >= l; i--)arr[b][i] = c++;
            b--;
            for(int i = b; i >= t; i--)arr[i][l] = c++;
            l++;
        }
        return arr;
    }

    public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] arr = new int[102];
        for (int num : nums) {
            arr[num]++;
        }
        for(int i = 1; i <= 100; i++){
            arr[i] += arr[i - 1];
        }
        for(int i = 0; i <= nums.length; i++){
            nums[i]  = nums[i] == 0 ? 0 : arr[nums[i]];
        }
        return nums;
    }
// https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/
//1769
    public int[] minOperations(String boxes)
        int n = boxes.length(), res = 0, carry = 0, num = 0;
//        char[] chars = boxes.toCharArray();
        int[] cnt = new int[n];
        for(int i = 1; i < n; i++) {
            char c = boxes.charAt(i);
            carry += num;
            if(c == '1') {
                num++;
                carry++;
            }
            cnt[i] = carry;
        }
        num = 0;
        carry = 0;
        for(int i = n - 2; i >= 0; i--) {
            char c = boxes.charAt(i);
            carry += num;
            if(c == '1') {
                num++;
                carry++;
            }
            cnt[i] += carry;
        }
        return cnt;

    }

            PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> b - a);
            int n = nums.length, max = Integer.MIN_VALUE;
            int i = 0;
            for (; i < k; i++) {
                q.add(nums[i]);
            }
            int[] res = new int[n - 2];
            int index = 0;
            res[index++] = q.peek();
            for (; i < n; i++) {
                q.remove(nums[i - 3]);
                q.add(nums[i]);
                res[index++] = q.peek();
            }
            return nums;
    public int[] maxSlidingWindow(int[] nums, int k) {
        LinkedList<Integer> q = new LinkedList<>();
        int i = 0, n = nums.length, index = 0;
        for(; i < k; i++) {
            while (!q.isEmpty() && nums[q.peekLast()] <= nums[i]) {
                q.pollLast();
            }
            q.addLast(i);
        }
        int[] res = new int[n - k + 1];
        res[index++] = nums[q.peekFirst()];
        for(; i < n; i++){
            if(!q.isEmpty() && q.peekFirst() <= i - k) {
                q.pollFirst();
            }
            while (!q.isEmpty() && nums[q.peekLast()] <= nums[i]) {
                q.pollLast();
            }
            q.addLast(i);
            res[index++] = nums[q.peekFirst()];
        }
        return res;
    }
        int[] ints = s.maxSlidingWindow(arr, 3);
        System.out.println(Arrays.toString(ints));

    final int INF = 1111;
    final TreeNode INF_NODE = new TreeNode(INF);

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) {
            return "";
        }
        LinkedList<TreeNode> q = new LinkedList<>();
        q.add(root);
        StringBuffer sb = new StringBuffer();
        while (!q.isEmpty()) {
            TreeNode poll = q.pollFirst();
            sb.append(poll.val).append("_");
            if (poll.val != INF) {
                q.addLast(poll.left == null ? INF_NODE : poll.left);
                q.addLast(poll.right == null ? INF_NODE : poll.right);
            }
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.equals("")) return null;
        LinkedList<TreeNode> q = new LinkedList<>();
        String[] arr = data.split("_");
        TreeNode root = new TreeNode(Integer.parseInt(arr[0]));
        q.addLast(root);
        for (int i = 1; i < arr.length; i += 2) {
            TreeNode treeNode = q.pollFirst();
            int a = Integer.parseInt(arr[i]), b = Integer.parseInt(arr[i + 1]);
            ;
            if (a != INF) {
                treeNode.left = new TreeNode(a);
                q.addLast(treeNode.left);
            }
            if (b != INF) {
                treeNode.right = new TreeNode(b);
                q.addLast(treeNode.right);
            }
        }
        return root;
    }

    public ListNode mergeKLists(ListNode[] lists) {
        int n = 0;
        if (lists.length == 0) return null;
        PriorityQueue<ListNode> q = new PriorityQueue<>((o1, o2) -> o1.val - o2.val);
        for (ListNode node : lists) {
            if (node != null) {
                q.add(node);
            }
        }
        ListNode mockHead = new ListNode(1);
        ListNode pre = mockHead;
        while (!q.isEmpty()) {
            ListNode poll = q.poll();
            int val = poll.val;
            pre.next = new ListNode(val);
            pre = pre.next;
            if (poll.next != null) q.add(poll.next);
        }
        return mockHead.next;
    }
   public static void main(String[] args) {
        Codec s = new Codec();
        s.minCut("leet");
    }
    public int minCut(String s) {
        char[] chars = s.toCharArray();
        int n = chars.length;
        boolean[][] dp = new boolean[n + 1][n + 1];
        for (int r2 = 1; r2 <= n; r2++) {
            for (int l2 = r2; l2 >= 1; l2--) {
                if (l2 == r2) {
                    dp[l2][r2] = true;
                } else if (chars[l2 - 1] == chars[r2 - 1]) {
                    if (l2 + 1 == r2 || dp[l2 + 1][r2 - 1]) {
                        dp[l2][r2] = true;
                    }
                }
            }
        }
        for(boolean[] d: dp) {
            System.out.println(Arrays.toString(d));
        }
        int[] dp2 = new int[n + 1];
        Arrays.fill(dp2, n - 1);
        dp2[0] = 0;
        for (int i = 1; i <= n; i++) {
            if (dp[1][i]) {
                dp2[i] = 0;
                continue;
            }
            for (int j = 1; j < i; j++) {
                if(dp[j + 1][i]) {
                    dp2[i] = Math.min(dp2[j] + 1, dp2[i]);
                }
            }
        }

        System.out.println(Arrays.toString(dp2));
        return dp2[n];
    }

    public int numDistinct(String s, String t) {
        int m = s.length(), n = t.length();
        char[] cs = s.toCharArray();
        char[] ct = t.toCharArray();
        int[][] dp = new int[m + 1][n + 1];

        for(int i = 0; i <= m; i++)dp[i][0] = 1;

        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++){
                dp[i][j] = dp[i - 1][j];
                if (cs[i - 1] == ct[j - 1]) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
        return dp[m][n];
    }
class Solution {
    public static void main(String[] args) {
        int[] arr = {1, 3, 1, 3, 5, 3, 6, 7};
        Solution s = new Solution();
        System.out.println(s.minWindow("ADOBECODEBANC", "ABC"));
    }

    public int secondHighest(String s) {
        int max = -1, second_max = -1;
        int n = s.length();
        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                int digit = c - '0';
                if (digit > max) {
                    second_max = max;
                    max = digit;
                }
            }
        }
        return second_max;
    }

    public String minWindow(String s, String t) {
        final int LEN = 50001;
        int m = s.length(), n = t.length();
        int[] arr = new int[128];
        int index = -1;
        for (int i = 0; i < n; i++) {
            arr[t.charAt(i)]++;
        }
        for (int i = 0; i < 128; i++) {
            if (arr[i] == 0) arr[i] = LEN;
        }
        int min = Integer.MAX_VALUE, l = 0, cnt = 0;
        String res = "";
        char[] chars = s.toCharArray();
        for (int i = 0; i < m; i++) {
            char c = chars[i];
            if (arr[c] == LEN) continue;
            arr[c]--;
            if (arr[c] >= 0) cnt++;
            while (arr[index = s.charAt(l)] < 0 || arr[index] == LEN) {
                if (arr[index] < 0) {
                    arr[index]++;
                }
                l++;
            }
            if (cnt == n && i - l + 1 < min) {
                min = i - l + 1;
                res = String.copyValueOf(chars, l, min);
            }
        }
        return res;
    }

    public int largestRectangleArea(int[] heights) {
        int n = heights.length, res = 0;
        int[] l = new int[n], r = new int[n];
        Arrays.fill(r, n);
        Arrays.fill(l, -1);
        LinkedList<Integer> q = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            while (!q.isEmpty() && heights[q.peekLast()] > heights[i]) r[q.pollLast()] = i;
            q.add(i);
        }
        q.clear();
        for (int i = n - 1; i >= 0; i--) {
            while (!q.isEmpty() && heights[q.peekLast()] > heights[i]) l[q.pollLast()] = i;
            q.add(i);
        }
        for (int i = 0; i < n; i++) {
            res = Math.max(heights[i] * (r[i] - l[i] - 1), res);
        }
        return res;
    }

    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int[][] sums = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int tmp = matrix[i][j] == '0' ? 0 : 1;
                if (i == 0) {
                    sums[i][j] = tmp;
                } else {
                    sums[i][j] = tmp == 1 ? sums[i - 1][j] + 1 : 0;
                }
            }
        }
        int res = 0;
        int[] left = new int[n], right = new int[n];
        for (int i = 0; i < m; i++) {
            int[] cur = sums[i];
            LinkedList<Integer> q = new LinkedList<>();

            Arrays.fill(left, -1);
            Arrays.fill(right, n);
            for (int j = 0; j < n; j++) {
                while (!q.isEmpty() && cur[q.peekLast()] > cur[j]) right[q.pollLast()] = j;
                q.addLast(j);
            }

            for (int j = n - 1; j >= 0; j--) {
                while (!q.isEmpty() && cur[q.peekLast()] > cur[j]) left[q.pollLast()] = j;
                q.add(j);
            }

            for (int j = 0; j < n; j++) {
                res = Math.max(res, cur[j] * (right[j] - left[j] - 1));
            }
        }
        return res;
    }
}

class Codec {
    public static void main(String[] args) {
        Codec c = new Codec();
        c.ladderLength("hit", "cog",
                new ArrayList<>(Arrays.asList("hot", "dot", "dog", "lot", "log", "cog")));
    }

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {

        int size = wordList.size(), level = 0;
        HashSet<String> set = new HashSet<>(wordList);
        if(!set.contains(endWord)){
            return 0;
        }
        LinkedList<String> q = new LinkedList<>();
        q.add(beginWord);
        HashMap<String, Integer> h1 = new HashMap<>();
        h1.put(beginWord, 1);

        LinkedList<String> q2 = new LinkedList<>();
        q2.add(endWord);
        HashMap<String, Integer> h2 = new HashMap<>();
        h2.put(endWord, 1);
        while (!q.isEmpty() && !q2.isEmpty()) {
            int s1 = q.size(), s2 = q2.size();
            HashMap<String, Integer> my_map = h1, another_map = h2;
            LinkedList<String> my_q = q;

            if(s1 > s2){
                my_map = h2;
                another_map = h1;
                my_q = q2;
            }

            LinkedList<String> new_q = new LinkedList<>();
            while (!my_q.isEmpty()) {
                String s = my_q.pollFirst();
                Integer my_level = my_map.get(s);

                for (Map.Entry<String, Integer> e : another_map.entrySet()) {
                    if(match(e.getKey(), s)){
                        return e.getValue() + my_level;
                    }
                }
                HashSet<String> tmp = new HashSet<>();
                for (String s3 : set) {
                    if(match(s3, s)){
                        my_map.put(s3, my_level + 1);
                        new_q.addLast(s3);
                        tmp.add(s3);
                    }
                }
                for (String s3 : tmp) {
                    set.remove(s3);
                }
            }

            if(s1 <= s2){
                q = new_q;
            } else {
                q2 = new_q;
            }

        }
        return 0;
    }

    public boolean match(String s, String t) {
        int m = s.length(), n = t.length();
        if (m != n) return false;
        if (s.equals(t)) {
            return true;
        }
        int cnt = 0;
        for (int i = 0; i < m; i++) {
            if (s.charAt(i) == t.charAt(i)) continue;
            cnt++;
            if (cnt > 1) return false;
        }
        return true;
    }
}
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return res;
    }

    public int dfs(TreeNode node) {
        if (node==null)return 0;
        int l = dfs(node.left), r = dfs(node.right);
        l = Math.max(l, 0);
        r = Math.max(r, 0);
        int max = node.val + l + r;
        res = Math.max(max, res);
        return node.val + Math.max(l, r);
    }
   void dfs(int[] toppingCosts, int p,  int curCosts){
        if(Math.abs(res - target) >= Math.abs(curCosts - target)){
            if(Math.abs(res - target) >Math.abs(curCosts - target)) {
                res = curCosts;
            }else {
                res = Math.min(curCosts, res);
            }
        }
        if(curCosts == target){
            res = target;
            return;
        }

        if(p == toppingCosts.length)return;
        int cur_cost = toppingCosts[p];
        dfs(toppingCosts, p + 1, cur_cost + curCosts);
        dfs(toppingCosts, p + 1, cur_cost * 2+ curCosts);
        dfs(toppingCosts, p + 1,  curCosts);
    }

    int biggerMin = Integer.MAX_VALUE;
    public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {
        int min = Arrays.stream(baseCosts).min().getAsInt();
        if(min >= target){
            return min;
        }
        int res = target * 2 - min;
        int n = toppingCosts.length;
        boolean[] dp = new boolean[target + 1];
        for (int baseCost : baseCosts) {
            if(baseCost <= target){
                dp[baseCost]  = true;
            } else {
                res = Math.min(res, baseCost);
            }
        }
        for (int cur_cost : toppingCosts) {
            for(int j = target; j >= 1; j--){
                boolean tmp = dp[j];
                for(int k = 1; k <= 2; k++){
                    int cost = cur_cost * k;
                    if(tmp && j + cost >= target){
                        res = Math.min(res, j + cost);
                    }
                    if(j - cost > 0){
                        dp[j] |= dp[j - cost];
                    }
                }
            }
        }

        for(int i = 0; i <= res - target; i++){
            if(dp[target - i])return target - i;
        }
        return res;
    }
    int res = Integer.MIN_VALUE / 10;
    int target = 0;
    int m;
    int n;
    static final int[][] dirs = new int[][]{{-1, 0}, {0, -1}, {1, 0}, {0, 1}};
    int[][] arr;
    public int longestIncreasingPath(int[][] matrix) {
        this.m = matrix.length;
        this.n = matrix[0].length;
        int res = 1;
        this.arr = new int[m][n];
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                res = Math.max(res, dfs(matrix, i, j));
            }
        }
        return res;
    }

    int dfs(int[][] matrix, int x, int y){
        if(arr[x][y] != 0)return arr[x][y];
        arr[x][y] = 1;
        for (int[] dir : dirs) {
            int new_x = x + dir[0], new_y = y + dir[1];
            if(new_x >= 0 && new_x< m && new_y >=0 && new_y < n && matrix[new_x][new_y] > matrix[x][y]){
                arr[x][y] = Math.max(arr[x][y], dfs(matrix, new_x, new_y) + 1);
            }
        }
        return arr[x][y];
    }
    s.closestCost(new int[]{2,3}, new int[]{4, 5, 100}, 18);
    int[] f;
    public int numSimilarGroups(String[] strs) {
        int n = strs.length;
        f = new int[n];
        for (int i = 0; i < n; i++) {
            f[i] = i;
        }

        for (int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++){
                int f1 = find(i), f2 = find(j);
                if(f1 == f2)continue;
                if(match(strs[i], strs[j])){
                    f[f1] = f2;
                }
            }
        }

        int res = 0;
        for (int i = 0; i < n; i++) {
            if(f[i] == i)res++;
        }
        return res;
    }

    public int find(int x){
        return x == f[x] ? x : (f[x] = find(f[x]));
    }

    public boolean match(String s1, String s2){
        int n1 = s1.length(), n2 = s2.length();
        if(n1 != n2)return false;
        int cnt = 0;
        for (int i = 0; i < n1; i++) {
            if(s1.charAt(i) != s2.charAt(i)){
                cnt++;
                if(cnt > 2)return false;
            }
        }
        return true;
    }
    static final int N = 26, M = N * N;
    int[] indexs = new int[N], rights = new int[M], lefts = new int[M];
    int[] in = new int[N];
    int idx = 0, cnt = 0;
    public String alienOrder(String[] words) {
        int n = words.length;
        Arrays.fill(indexs, -1);
        for (int i = 0; i < n; i++) {
            String s2 = words[i];
            for (int j = 0; j < s2.length(); j++) {
                cnt |= 1 << (int)(s2.charAt(j) - 'a');
            }

            for(int j = 0; j < i; j++){
                String s1 = words[j];
                if(!match(s1, s2))return "";
            }
        }
        LinkedList<Integer> q = new LinkedList<>();
        String tt = Integer.toString(cnt, 2);
        for (int i = 0; i < N; i++) {
            boolean exist = ((1 << i) & cnt) != 0;
            if(exist && in[i] == 0){
                q.addLast(i);
            }
        }
        int tmp = Integer.bitCount(cnt);

        StringBuffer sb = new StringBuffer();
        while (!q.isEmpty()){
            Integer i = q.pollFirst();
            sb.append((char) (i + 'a'));
            for (int index = indexs[i]; index != -1; index = lefts[index]){
                int right = rights[index];
                in[right]--;
                if(in[right] == 0)q.addLast(right);
            }
        }
        String s = sb.toString();
        System.out.println(s);
        return s.length() == Integer.bitCount(cnt) ? s : "";
    }

    void add(int left, int right){
        rights[idx] = right;
        lefts[idx] = indexs[left];
        indexs[left] = idx;
        idx++;
        in[right]++;
    }
    boolean match(String s1, String s2) {
        int m = s1.length(), n = s2.length(), len = Math.min(m, n);
        for (int i = 0; i < len; i++) {
            char c1 = s1.charAt(i), c2 = s2.charAt(i);
            if(c1 != c2){
                add(c1 - 'a', c2 - 'a');
                return true;
            }
        }
        return m <= n;
    }
    static final int N = 26, M = N * N;
    int[] indexs = new int[N], rights = new int[M], lastIndexs = new int[M];
    int[] in = new int[N];
    int idx = 0, cnt = 0;
    public String alienOrder(String[] words) {
        int n = words.length;
        Arrays.fill(indexs, -1);
        for (int i = 0; i < n; i++) {
            String s2 = words[i];
            for (int j = 0; j < s2.length(); j++) {
                char c = s2.charAt(j);
                cnt |= (1 << (c - 'a'));
            }
            for(int j = 0; j < i; j++){
                String s1 = words[j];
                if(!sorted(s1, s2))return "";
            }
        }

        LinkedList<Integer> q = new LinkedList<>();
        for (int i = 0; i < N; i++) {
            boolean e = ((1 << i) & cnt) != 0;
            if(e && in[i] == 0){
                q.addLast(i);
            }
        }

        StringBuffer sb = new StringBuffer();
        while (!q.isEmpty()){
            Integer i = q.pollFirst();
            sb.append((char)(i + 'a'));
            for (int index = indexs[i]; index != -1; index = lastIndexs[index]) {
                int right = rights[index];
                in[right]--;
                if(in[right] ==0)q.addLast(right);
            }
        }
        int c = Integer.bitCount(cnt);
        return c == sb.length() ? sb.toString() : "";
    }
    void add(int left, int right) {
        rights[idx] = right;
        lastIndexs[idx] = indexs[left];
        indexs[left] = idx;
        idx++;
        in[right]++;
    }
    boolean sorted(String s1, String s2) {
        int n1 = s1.length(), n2 = s2.length(), len = Math.min(n1, n2);
        for (int i = 0; i < len; i++) {
            char c1 = s1.charAt(i), c2 = s2.charAt(i);
            if(c1 != c2){
                add(c1 - 'a', c2 - 'a');
                return true;
            }
        }
        return n1 <= n2;
    }

        int[] dp = new int[n + 10], neg = new int[n + 10], weights = new int[n + 10];
        int neg_tmp = 0, w_tmp = 0;
        for (int i = 1; i <= n; i++) {
            if(i > 1){
                neg_tmp += boxes[i - 1][0] == boxes[i - 2][0] ? 0 : 1;
                neg[i] = neg_tmp;
            }
            w_tmp += boxes[i - 1][1];
            weights[i] = w_tmp;
        }

        LinkedList<Integer> q = new LinkedList<>();
        q.addLast(0);
        int[] g = new int[n + 10];
        for(int i = 1; i <= n; i++){
            while (!q.isEmpty() && (i - q.peekFirst() > maxBoxes || weights[i] - weights[q.peekFirst()] > maxWeight)){
                q.pollFirst();
            }
            dp[i] = g[q.peekFirst()] + neg[i] + 2;

            if(i != n){
                // f[i] = f[j] + neg[i] - neg[j + 1] + 2
                // g[j] = f[j] - neg[j+1]
                g[i] = dp[i] - neg[i + 1];
                while (!q.isEmpty() && g[q.peekLast()] >= g[i])q.pollLast();
                q.addLast(i);
            }
        }
        return dp[n];

    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {
        int n = boxes.length;
        int[] weights = new int[n + 1], neg = new int[n + 1];
        int carry = 0;
        for(int i = 1; i <= n; i++){
            if(i > 1){
                carry  += boxes[i - 1][0] == boxes[i - 2][0] ? 0 : 1;
                neg[i] = carry;
            }
            weights[i] = weights[i - 1] + boxes[i - 1][1];
        }
        LinkedList<Integer> q = new LinkedList<>();
        q.addLast(0);
        int[] f = new int[n + 1];
        int[] g = new int[n + 1];
        // f[i] = f[j] + neg[i] - neg[j + 1] + 2
        // g[j] = f[j] - neg[j + 1]

        for(int i = 1; i <= n; i++){
            while (!q.isEmpty() && (i - q.peekFirst() > maxBoxes ||
                    weights[i] - weights[q.peekFirst()]  > maxWeight)){
                q.pollFirst();
            }
            f[i] = g[q.peekFirst()] + neg[i] + 2;
            if(n != i){
                g[i] = f[i] - neg[i + 1];
                while (!q.isEmpty() && g[q.peekLast()] >= g[i])q.pollLast();
                q.addLast(i);
            }
        }
        return f[n];
    }
   public static void main(String[] args) {
        Solution s = new Solution();
//        s.boxDelivering(new int[][]{{1, 1}, {2,1 }, {1,1}}, 2, 3, 3);
    }


    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n1 = nums1.length, n2 = nums2.length;
        int n = (n1 + n2 + 1) / 2, nn = n + (n1 + n2) % 2 == 0 ? 1 : 0;
        return (getKthElement(nums1, nums2, n) + getKthElement(nums1, nums2, nn)) / 2.0;
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        int m = nums1.length, n = nums2.length;
        int index1 = 0, index2 = 0, k2 = k;
        while (true){
            if(index1 == m)return nums2[k - index1 - 1];
            if(index2 == n)return nums1[k - index2 - 1];
            if(k2 == 1)return Math.min(nums1[index1], nums2[index2]);

            int half = k2 / 2;
            int newIndex1 = Math.min(m, index1 + half) - 1;
            int newIndex2 = Math.min(n , index2 + half) - 1;

            if(nums1[newIndex1] <= nums2[newIndex2]){

                k2 -= newIndex1 - index1 + 1;
                index1 = newIndex1 + 1;
            } else {
                k2 -= newIndex2 - index2 + 1;
                index2 = newIndex2 + 1;
            }
        }
    }

    public int trap(int[] height) {
        int ans = 0;
        LinkedList<Integer> q = new LinkedList<>();
        int n = height.length;
        for (int i = 0; i < n; i++) {
            while (!q.isEmpty() && height[q.peekLast()] < height[i]){
                int bottom = q.pollLast();
                if(q.isEmpty())break;
                int left = q.peekLast();
                int width = i - left + 1;
                int h = height[bottom];
                ans += width * (height[i] - h);
            }
            q.addLast(i);
        }
        return ans;
    }




    public int getKthElement2(int[] nums1, int[] nums2, int k) {

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }

            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }

    public int minOperations(int[] nums1, int[] nums2) {
        int d = 0;
        int[] a = new int[7], b = new int[7];
        for (int i : nums1) {
            d -= i;
            a[i]++;
        }
        for (int i : nums2) {
            d += i;
            b[i]++;
        }
        if ( d == 0)return 0;
        if(d > 0)return cnt(a, b, d);
        return cnt(b, a, -d);
    }

    int cnt(int[] a, int[] b, int d){
        int[] h = new int[7];
        int ans = 0;
        for(int i = 1; i < 7; i++){
            h[i - 1] += b[i];
            h[6 - i] += a[i];
        }
        for(int i = 5; i > 0 && d > 0; i--){
            if(h[i] * i >= d)return ans += (d + i - 1) / i;
            d -= h[i] * i;
            ans += h[i];
        }
        return -1;
    }
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(), pre = dummy;
        pre.next = head;
        while (true){
            ListNode pre2 = pre;
            for(int i = 0; i < k && pre2 != null; i++){
                pre2 = pre2.next;
            }
            if(pre2 == null)break;
            ListNode next_head = pre2.next, cur_tail = pre2, cur_head = pre.next;
            ListNode[] reverse = reverse(cur_head, cur_tail, k);
            pre.next = reverse[0];
            reverse[1].next = next_head;

            pre = reverse[1];
        }
        return dummy.next;
    }
    ListNode[] reverse(ListNode cur_head, ListNode cur_tail, int k) {
        ListNode pre = null, p = cur_head;
        for(int i = 0; i < k; i++){
            ListNode tmp = p.next;
            p.next = pre;
            pre = p;
            p = tmp;
        }

        return new ListNode[]{cur_tail, cur_head};
    }
 public static void main(String[] args) {
        Solution s = new Solution();
//        s.minOperations(new int[]{5, 6, 4, 3, 1, 2}, new int[]{6, 3, 3, 1, 4, 5, 3, 4, 1, 3, 4});
        s.findSubstring("barfoothefoobarman", new String[]{"foo","bar"});
    }

    public List<Integer> findSubstring(String s, String[] words) {
        int m = s.length(), n = words.length, w = words[0].length();
        int mw = m * w;
        ArrayList<Integer> ans = new ArrayList<>();
        HashMap<String, Integer> map = new HashMap<>();
        for (String word : words) {
            map.put(word, map.getOrDefault(word, 0) + 1);
        }

        for (int i = 0; i + n * w <= m && i < w; i++) {
            HashMap<String, Integer> temp = new HashMap<>();
            for (int j = i; j + w <= m; j += w) {
                String cur = s.substring(j, j + w);
                temp.put(cur, temp.getOrDefault(cur, 0) + 1);
                if (j - n * w >= i) {
                    int idx = j - n * w;
                    String prev = s.substring(idx, idx + w);
                    if (temp.get(prev) == 1) temp.remove(prev);
                    else temp.put(prev, temp.get(prev) - 1);
                    if (!temp.getOrDefault(prev, 0).equals(map.getOrDefault(prev, 0))) continue;
                    if (temp.getOrDefault(prev, 0) != map.getOrDefault(prev, 0)) continue;
                }
                if (temp.getOrDefault(cur, 0) != map.getOrDefault(cur, 0)) continue;
                System.out.println(111);
                if (map.equals(temp)) ans.add(j - n * w + w);
            }

        }
        return ans;
    }

